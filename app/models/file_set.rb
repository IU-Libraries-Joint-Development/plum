require 'vocab/pul_terms'

# Generated by curation_concerns:models:install
class FileSet < ActiveFedora::Base # rubocop:disable Metrics/ClassLength
  include ::CurationConcerns::FileSetBehavior
  include ExtraLockable
  Hydra::Derivatives.output_file_service = PersistPairtreeDerivatives

  property :replaces, predicate: ::RDF::Vocab::DC.replaces, multiple: false
  # override inherited identifier to disallow multiple
  property(:identifier,
           predicate: ::RDF::Vocab::DC.identifier,
           multiple: false)
  property(:source_metadata_identifier,
           predicate: ::PULTerms.metadata_id,
           multiple: false) do |index|
    index.as :stored_searchable, :symbol
  end

  apply_schema IIIFPageSchema, ActiveFedora::SchemaIndexingStrategy.new(
    ActiveFedora::Indexers::GlobalIndexer.new(%i[stored_searchable symbol])
  )
  before_save :normalize_identifiers
  after_save :touch_parent_works

  validates_with ViewingHintValidator

  def self.image_mime_types
    []
  end

  def iiif_path
    IIIFPath.new(id).to_s
  end

  # rubocop:disable Metrics/AbcSize, Metrics/MethodLength
  def create_derivatives(filename)
    case mime_type
    when /(image\/tiff|external)/
      Hydra::Derivatives::Jpeg2kImageDerivatives.create(
        filename, outputs: [
          label: 'intermediate_file',
          service: { datastream: 'intermediate_file', recipe: :default },
          url: derivative_url('intermediate_file')
        ]
      )
      create_ocr(id, filename)
      create_word_boundaries(id)
    when /image\/jp2/
      dst = derivative_path('intermediate_file')
      FileUtils.mkdir_p(File.dirname(dst))
      FileUtils.cp(filename, dst)
      create_ocr(id, filename)
      create_word_boundaries(id)
    when /text\/plain/
      if filename.end_with?("fulltext.txt")
        dst = derivative_path('ocr', 'txt')
        FileUtils.mkdir_p(File.dirname(dst))
        FileUtils.cp(filename, dst)
      end
    end
    super
  end
  # rubocop:enable Metrics/AbcSize, Metrics/MethodLength

  def to_solr(solr_doc = {})
    super.tap do |doc|
      doc["full_text_tesim"] = ocr_text if ocr_text.present?
      doc["ordered_by_ssim"] = ordered_by.map(&:id).to_a
    end
  end

  def ocr_document
    return unless persisted? && File.exist?(ocr_file.gsub("file:", ""))
    @ocr_document ||=
      begin
        file = File.open(ocr_file.gsub("file:", ""))
        HOCRDocument.new(file)
      end
  end

  private

    def touch_parent_works
      TouchParentJob.perform_later(self)
    end

    # OCR file if configuration allows
    #
    # @param id [String] Fileset id
    def create_ocr(id, filename)
      return unless Plum.config[:create_hocr_files]

      # If store_original_files is false, explicitly call the OCRRunner
      # since RunOCRJob only uses the stored content object as the source
      # and doesn't know about the original file
      RunOCRJob.perform_now(id) if Plum.config[:store_original_files]
      OCRRunner.new(self).from_original_file(filename) unless
        Plum.config[:store_original_files]
    end

    def create_word_boundaries(id)
      RunWordBoundariesJob.perform_later(id) if
        Plum.config[:create_word_boundaries]
    end

    def ocr_file
      derivative_url('ocr')
    end

    def ocr_text
      if Plum.config[:create_hocr_files] && Plum.config[:index_hocr_files]
        ocr_document.try(:text).try(:strip)
      else
        return false unless File.exist?(derivative_path('ocr', 'txt'))
        File.open(derivative_path('ocr', 'txt')).read
      end
    end

    # The destination_name parameter has to match up with the file parameter
    # passed to the DownloadsController
    def derivative_url(destination_name)
      path = PairtreeDerivativePath \
             .derivative_path_for_reference(self, destination_name)
      URI("file://#{path}").to_s
    end

    def derivative_path(destination_name, ext = false)
      if ext
        PairtreeDerivativePath \
          .derivative_path_for_reference(self, destination_name) \
          .to_s.sub(/.[^\.]+$/, ".#{ext}")
      else
        PairtreeDerivativePath \
          .derivative_path_for_reference(self, destination_name).to_s
      end
    end

    def normalize_identifiers
      return if label.nil?
      self.source_metadata_identifier =
        label.gsub(/\.\w{3,4}$/, '').upcase
    end
end
